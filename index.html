<!DOCTYPE html>
<html>

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Create a simple animation with moving elements</title>

  <style>
    
  </style>

  
</head>
<body>
  <!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ò–≥—Ä–∞-–ø–∞–∑–ª (–ü—è—Ç–Ω–∞—à–∫–∏) - –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/tone"></script>
    <style>
        /* –ò—Å–ø–æ–ª—å–∑—É–µ–º —à—Ä–∏—Ñ—Ç Inter */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #a3a3a3; /* –§–æ–Ω –¥–ª—è –¥–æ–∂–¥—è */
            overflow: hidden;
            position: relative;
        }
        /* Canvas –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –¥–æ–∂–¥—è */
        #rain-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –∏–≥—Ä—ã */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
            z-index: 1;
            position: relative;
            max-width: 95vw;
            width: 95%; /* –ò–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—É—é —à–∏—Ä–∏–Ω—É */
            max-height: 95vh; /* –î–æ–±–∞–≤–ª–µ–Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ */
            height: auto;
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ (—Ä–∞–∑–º–µ—Ä, —Ç–∞–π–º–µ—Ä, —Ä–µ–∂–∏–º) */
        .settings {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .settings label {
            margin-right: 5px;
            font-weight: bold;
            color: #374151;
        }
        .settings select, .settings span {
            padding: 5px 8px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
        }
        #timer {
            font-weight: bold;
            color: #1f2937;
            background-color: #f3f4f6;
            min-width: 60px;
            text-align: center;
        }

        /* –°—Ç–∏–ª–∏ –¥–ª—è —Å–µ—Ç–∫–∏ –ø–∞–∑–ª–∞ */
        #puzzle-grid {
            display: grid;
            /* grid-template-columns –∏ gap –±—É–¥—É—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ JS */
            /* –†–∞–∑–º–µ—Ä—ã —Ç–∞–∫–∂–µ –±—É–¥—É—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ JS */
            border: 2px solid #9ca3af;
            border-radius: 8px;
            padding: 5px;
            margin-bottom: 20px;
            background-color: #d1d5db;
            width: 100%; /* –ó–∞–Ω–∏–º–∞–µ—Ç –≤—Å—é –¥–æ—Å—Ç—É–ø–Ω—É—é —à–∏—Ä–∏–Ω—É –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ */
            height: auto;
            aspect-ratio: 1 / 1;
            max-width: 500px; /* –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —à–∏—Ä–∏–Ω–∞ */
            max-height: 500px; /* –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ */
            overflow: hidden;
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è –ø–ª–∏—Ç–æ–∫ */
        .tile {
            display: flex;
            justify-content: center;
            align-items: center;
            /* font-size –±—É–¥–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ JS */
            font-weight: bold;
            background-color: #60a5fa;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.15s ease, transform 0.15s ease;
            user-select: none;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.1);
            /* width/height –±—É–¥—É—Ç —Ä–∞–≤–Ω—ã —á–µ—Ä–µ–∑ grid */
            overflow: hidden; /* –°–∫—Ä—ã–≤–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ, –≤—ã—Ö–æ–¥—è—â–µ–µ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã */
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        /* –°—Ç–∏–ª—å –¥–ª—è –ø—É—Å—Ç–æ–π –ø–ª–∏—Ç–∫–∏ */
        .tile.empty {
            background-color: #9ca3af;
            cursor: default;
            box-shadow: none;
        }
        /* –°—Ç–∏–ª—å –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ –Ω–∞ –ø–ª–∏—Ç–∫—É (–∫—Ä–æ–º–µ –ø—É—Å—Ç–æ–π) */
        .tile:not(.empty):hover {
            background-color: #3b82f6;
            transform: scale(1.05);
            z-index: 2;
            position: relative;
        }
        /* –°—Ç–∏–ª—å –¥–ª—è –∫–Ω–æ–ø–∫–∏ */
        button {
            padding: 10px 20px;
            font-size: 1rem;
            color: white;
            background-color: #10b981;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-top: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            width: auto; /* –ö–Ω–æ–ø–∫–∞ –ø–æ–¥—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è –ø–æ–¥ –∫–æ–Ω—Ç–µ–Ω—Ç */
        }
        button:hover {
            background-color: #059669;
        }
        /* –°—Ç–∏–ª—å –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è */
        #message {
            margin-top: 15px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #059669;
            min-height: 22px;
            text-align: center;
            width: 100%;
        }
        .settings {
            display: flex;
            justify-content: space-between; /* –†–∞–∑–º–µ—â–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ –∫—Ä–∞—è–º */
            align-items: center; /* –í—ã—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ */
            width: 100%;
            margin-bottom: 15px;
            flex-wrap: wrap; /* –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–Ω–æ—Å –Ω–∞ –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É, –µ—Å–ª–∏ –Ω–µ –ø–æ–º–µ—â–∞–µ—Ç—Å—è */
            gap: 10px; /* –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç—Å—Ç—É–ø –º–µ–∂–¥—É —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ */
        }

        .settings > div, .settings > span {
            margin-right: 0; /* –£–±–∏—Ä–∞–µ–º –æ—Ç—Å—Ç—É–ø —Å–ø—Ä–∞–≤–∞ —É –¥–æ—á–µ—Ä–Ω–∏—Ö div –∏ span */
            margin-bottom: 10px; /* –¥–æ–±–∞–≤–ª—è–µ–º –æ—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="rain-canvas"></canvas>

    <div class="game-container">
        <h1 class="text-2xl font-bold mb-4 text-gray-800">–ü–∞–∑–ª "–ü—è—Ç–Ω–∞—à–∫–∏"</h1>

        <div class="settings">
            <div>
                <label for="size-select">–†–∞–∑–º–µ—Ä:</label>
                <select id="size-select">
                    <option value="3">3x3</option>
                    <option value="4">4x4</option>
                    <option value="5">5x5</option>
                    <option value="6">6x6</option>
                    <option value="7">7x7</option>
                    <option value="8">8x8</option>
                    <option value="9">9x9</option>
                    <option value="10">10x10</option>
                </select>
            </div>
            <div>
                <label for="mode-select">–†–µ–∂–∏–º:</label>
                <select id="mode-select">
                    <option value="classic">–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π</option>
                    <option value="timed">–ù–∞ –≤—Ä–µ–º—è</option>
                    <option value="moves">–ù–∞ —Ö–æ–¥—ã</option>
                </select>
            </div>
            <div>
                <label>–í—Ä–µ–º—è:</label>
                <span id="timer">00:00</span>
            </div>
            <div id="moves-counter" style="display: none;">
                <label>–•–æ–¥—ã:</label>
                <span id="moves-count">0</span>
            </div>
        </div>

        <div id="puzzle-grid"></div>
        <div id="message"></div>
        <button id="shuffle-button">–ù–∞—á–∞—Ç—å / –ü–µ—Ä–µ–º–µ—à–∞—Ç—å</button>
    </div>

    <script>
        // --- –≠–ª–µ–º–µ–Ω—Ç—ã DOM ---
        const gridElement = document.getElementById('puzzle-grid');
        const messageElement = document.getElementById('message');
        const shuffleButton = document.getElementById('shuffle-button');
        const sizeSelect = document.getElementById('size-select');
        const timerElement = document.getElementById('timer');
        const modeSelect = document.getElementById('mode-select');
        const movesCounterElement = document.getElementById('moves-counter');
        const movesCountElement = document.getElementById('moves-count');

        // --- –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã ---
        let puzzleSize = parseInt(sizeSelect.value);
        const emptyTileValue = null;
        let tiles = [];
        let emptyIndex = -1;
        let timerInterval = null;
        let startTime = 0;
        let gameInProgress = false;
        let movesCount = 0; // –°—á–µ—Ç—á–∏–∫ —Ö–æ–¥–æ–≤
        let gameMode = 'classic'; // –†–µ–∂–∏–º –∏–≥—Ä—ã: 'classic', 'timed', 'moves'
        let movesLimit = 0; // –õ–∏–º–∏—Ç —Ö–æ–¥–æ–≤ –¥–ª—è —Ä–µ–∂–∏–º–∞ 'moves'

        // --- –ó–≤—É–∫–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã (Tone.js) ---
        const moveSynth = new Tone.Synth().toDestination();
        const winSynth = new Tone.Synth().toDestination();
        const shuffleSynth = new Tone.Synth().toDestination();

        function playMoveSound() {
            moveSynth.triggerAttackRelease("C4", "8n");
        }

        function playWinSound() {
           // winSynth.triggerAttackRelease("G4", "1n");  // Simple tone
            // More complex sound (a short chord progression)
            const now = Tone.now();
            winSynth.triggerAttackRelease("C5", "8n", now);
            winSynth.triggerAttackRelease("E5", "8n", now + 0.2);
            winSynth.triggerAttackRelease("G5", "8n", now + 0.4);
            winSynth.triggerAttackRelease("C6", "1n", now + 0.6);
        }

        function playShuffleSound() {
            // shuffleSynth.triggerAttackRelease("C3", "4n"); // Simple tone
            // More complex sound (a quick slide)
             const now = Tone.now();
              shuffleSynth.triggerAttackRelease("C3", "8n", now);
              shuffleSynth.triggerAttackRelease("D3", "8n", now + 0.1);
              shuffleSynth.triggerAttackRelease("E3", "8n", now + 0.2);
              shuffleSynth.triggerAttackRelease("F3", "8n", now + 0.3);
        }



        // --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ü–∞–∑–ª–∞ (1D –º–∞—Å—Å–∏–≤) ---
        function initializePuzzle() {
            puzzleSize = parseInt(sizeSelect.value);
            const totalTiles = puzzleSize * puzzleSize;
            tiles = [];
            for (let i = 1; i < totalTiles; i++) {
                tiles.push(i);
            }
            tiles.push(emptyTileValue);
            emptyIndex = totalTiles - 1;
            messageElement.textContent = '';
            gameInProgress = false;
            resetTimer();
            movesCount = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ —Ö–æ–¥–æ–≤
            movesCountElement.textContent = movesCount; // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ö–æ–¥–æ–≤
            if (gameMode === 'moves') {
                movesCounterElement.style.display = 'flex';
                movesLimit = puzzleSize * puzzleSize * 2; // –ü—Ä–∏–º–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ª–∏–º–∏—Ç–∞ —Ö–æ–¥–æ–≤
                messageElement.textContent = `–õ–∏–º–∏—Ç —Ö–æ–¥–æ–≤: ${movesLimit}`;
            } else {
                movesCounterElement.style.display = 'none';
            }
        }

        // --- –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ü–∞–∑–ª–∞ ---
        function renderPuzzle() {
            gridElement.innerHTML = '';
            gridElement.style.gridTemplateColumns = `repeat(${puzzleSize}, 1fr)`;
            gridElement.style.gap = `${Math.max(1, 6 - puzzleSize)}px`;

            const gridWidth = gridElement.clientWidth;
            const tileSize = (gridWidth - (puzzleSize + 1) * parseFloat(gridElement.style.gap)) / puzzleSize;
            const fontSize = Math.max(8, tileSize * 0.4);

            tiles.forEach((value, index) => {
                const tile = document.createElement('div');
                tile.classList.add('tile');
                tile.style.fontSize = `${fontSize}px`;

                if (value === emptyTileValue) {
                    tile.classList.add('empty');
                    tile.textContent = '';
                } else {
                    tile.textContent = value;
                    tile.addEventListener('click', () => handleTileClick(index));
                }
                tile.style.width = `${tileSize}px`;
                tile.style.height = `${tileSize}px`;
                gridElement.appendChild(tile);
            });
        }

        // --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –ö–ª–∏–∫–∞ –ø–æ –ü–ª–∏—Ç–∫–µ ---
        function handleTileClick(tileIndex) {
            if (!gameInProgress) return;

            if (isAdjacent(tileIndex, emptyIndex)) {
                swapTiles(tileIndex, emptyIndex);
                emptyIndex = tileIndex;
                renderPuzzle();
                movesCount++; // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ —Ö–æ–¥–æ–≤
                movesCountElement.textContent = movesCount; // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫ —Ö–æ–¥–æ–≤ –Ω–∞ —ç–∫—Ä–∞–Ω–µ
                playMoveSound(); // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ –ø–ª–∏—Ç–∫–∏

                if (gameMode === 'moves' && movesCount >= movesLimit) {
                    stopTimer();
                    messageElement.textContent = `‚òπÔ∏è –í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏! –•–æ–¥—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å.`;
                    gameInProgress = false;
                    return;
                }

                if (isSolved()) {
                    stopTimer();
                    playWinSound(); // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –ø–æ–±–µ–¥—ã
                    let message = `üéâ –ü–∞–∑–ª ${puzzleSize}x${puzzleSize} —Å–æ–±—Ä–∞–Ω! `;
                    if (gameMode === 'timed') {
                        message += `–í—Ä–µ–º—è: ${timerElement.textContent}! `;
                    }
                    message += `–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ö–æ–¥–æ–≤: ${movesCount} üéâ`;
                    messageElement.textContent = message;
                    gameInProgress = false;
                }
            }
        }

        // --- –ü—Ä–æ–≤–µ—Ä–∫–∞ –°–æ—Å–µ–¥—Å—Ç–≤–∞ –ü–ª–∏—Ç–æ–∫ (1D) ---
        function isAdjacent(index1, index2) {
            const row1 = Math.floor(index1 / puzzleSize);
            const col1 = index1 % puzzleSize;
            const row2 = Math.floor(index2 / puzzleSize);
            const col2 = index2 % puzzleSize;

            return (Math.abs(row1 - row2) === 1 && col1 === col2) || (Math.abs(col1 - col2) === 1 && row1 === row2);
        }

        // --- –û–±–º–µ–Ω –ü–ª–∏—Ç–æ–∫ (1D) ---
        function swapTiles(index1, index2) {
            [tiles[index1], tiles[index2]] = [tiles[index2], tiles[index1]];
        }

        // --- –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ –ü–∞–∑–ª–∞ (–¥–µ–ª–∞–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–µ —Ö–æ–¥—ã) ---
        function shufflePuzzle() {
            initializePuzzle();

            const shuffleMoves = puzzleSize * puzzleSize * (5 + puzzleSize);
            let lastMovedIndex = -1;

            for (let i = 0; i < shuffleMoves; i++) {
                const possibleMoves = [];
                const emptyRow = Math.floor(emptyIndex / puzzleSize);
                const emptyCol = emptyIndex % puzzleSize;

                const directions = [
                    { dr: -1, dc: 0 },
                    { dr: 1, dc: 0 },
                    { dr: 0, dc: -1 },
                    { dr: 0, dc: 1 }
                ];

                for (const dir of directions) {
                    const neighborRow = emptyRow + dir.dr;
                    const neighborCol = emptyCol + dir.dc;

                    if (neighborRow >= 0 && neighborRow < puzzleSize && neighborCol >= 0 && neighborCol < puzzleSize) {
                        const neighborIndex = neighborRow * puzzleSize + neighborCol;
                        if (neighborIndex !== lastMovedIndex) {
                            possibleMoves.push(neighborIndex);
                        }
                    }
                }

                if (possibleMoves.length > 0) {
                    const randomMoveIndex = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    lastMovedIndex = emptyIndex;
                    swapTiles(randomMoveIndex, emptyIndex);
                    emptyIndex = randomMoveIndex;
                } else {
                    i--;
                }
            }

            messageElement.textContent = '';
            renderPuzzle();
            startTimer();
            gameInProgress = true;
            movesCount = 0; // –ù–∞—á–∏–Ω–∞–µ–º —Å—á–∏—Ç–∞—Ç—å —Ö–æ–¥—ã –ø–æ—Å–ª–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è
            movesCountElement.textContent = movesCount;
            playShuffleSound(); // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–∏
        }

        // --- –ü—Ä–æ–≤–µ—Ä–∫–∞, –†–µ—à–µ–Ω –ª–∏ –ü–∞–∑–ª (1D) ---
        function isSolved() {
            for (let i = 0; i < tiles.length - 1; i++) {
                if (tiles[i] !== i + 1) {
                    return false;
                }
            }
            return tiles[tiles.length - 1] === emptyTileValue;
        }

        // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¢–∞–π–º–µ—Ä–æ–º ---
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function startTimer() {
            if (gameMode === 'classic' || gameMode === 'moves') return; // –¢–∞–π–º–µ—Ä —Ç–æ–ª—å–∫–æ –¥–ª—è —Ä–µ–∂–∏–º–∞ 'timed'

            stopTimer();
            startTime = Date.now();
            timerElement.textContent = formatTime(0);
            timerInterval = setInterval(() => {
                const elapsedTime = Date.now() - startTime;
                timerElement.textContent = formatTime(elapsedTime);
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        function resetTimer() {
            stopTimer();
            timerElement.textContent = '00:00';
            startTime = 0;
        }

        // --- –õ–æ–≥–∏–∫–∞ –≠—Ñ—Ñ–µ–∫—Ç–∞ –î–æ–∂–¥—è ---
        const canvas = document.getElementById('rain-canvas');
        const ctx = canvas.getContext('2d');
        let drops = [];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initializeDrops();
        }

        class RainDrop {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * -canvas.height;
                this.length = Math.random() * 20 + 10;
                this.speed = Math.random() * 5 + 2;
                this.opacity = Math.random() * 0.5 + 0.3;
            }
            update() {
                this.y += this.speed;
                if (this.y > canvas.height) {
                    this.y = Math.random() * -50 - 20;
                    this.x = Math.random() * canvas.width;
                    this.speed = Math.random() * 5 + 2;
                    this.length = Math.random() * 20 + 10;
                    this.opacity = Math.random() * 0.5 + 0.3;
                }
            }
            draw() {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + this.length);
                ctx.strokeStyle = `rgba(173, 216, 230, ${this.opacity})`;
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }

        function initializeDrops() {
            drops = [];
            const numberOfDrops = Math.floor(canvas.width / 5);
            for (let i = 0; i < numberOfDrops; i++) {
                drops.push(new RainDrop());
            }
        }

        function animateRain() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drops.forEach(drop => {
                drop.update();
                drop.draw();
            });
            requestAnimationFrame(animateRain);
        }

        // --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π ---
        shuffleButton.addEventListener('click', shufflePuzzle);
        sizeSelect.addEventListener('change', () => {
            initializePuzzle();
            renderPuzzle();
            messageElement.textContent = getStartMessage();
        });
        modeSelect.addEventListener('change', () => {
            gameMode = modeSelect.value;
            initializePuzzle();
            renderPuzzle();
            resetTimer();
            movesCount = 0;
            movesCountElement.textContent = movesCount;
            if (gameMode === 'moves') {
                movesCounterElement.style.display = 'flex';
                movesLimit = puzzleSize * puzzleSize * 2;
                messageElement.textContent = `–õ–∏–º–∏—Ç —Ö–æ–¥–æ–≤: ${movesLimit}`;
            } else {
                movesCounterElement.style.display = 'none';
                messageElement.textContent = getStartMessage();
            }
        });

        window.addEventListener('resize', () => {
            resizeCanvas();
            renderPuzzle();
        });

        // --- –§—É–Ω–∫—Ü–∏–∏ ---

        function getStartMessage() {
            switch (gameMode) {
                case 'classic':
                    return '–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–º–µ—Ä –∏ –Ω–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å / –ü–µ—Ä–µ–º–µ—à–∞—Ç—å"';
                case 'timed':
                    return '–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–º–µ—Ä –∏ –Ω–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å / –ü–µ—Ä–µ–º–µ—à–∞—Ç—å".  –ò–≥—Ä–∞ –Ω–∞ –≤—Ä–µ–º—è!';
                case 'moves':
                    return `–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–º–µ—Ä –∏ –Ω–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å / –ü–µ—Ä–µ–º–µ—à–∞—Ç—å".  –õ–∏–º–∏—Ç —Ö–æ–¥–æ–≤: ${movesLimit}`;
                default:
                    return '–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–º–µ—Ä –∏ –Ω–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å / –ü–µ—Ä–µ–º–µ—à–∞—Ç—å"';
            }
        }

        // --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏ –ó–∞–ø—É—Å–∫ ---
        window.onload = () => {
            resizeCanvas();
            animateRain();
            initializePuzzle();
            renderPuzzle();
            messageElement.textContent = getStartMessage();
        };
    </script>
</body>
</html>


  <script>
    
  </script>
</body>
</html>
